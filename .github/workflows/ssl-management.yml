name: SSL Certificate Management

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'SSL Action to perform'
        required: true
        default: 'setup'
        type: choice
        options:
          - setup
          - renew
          - check-status
          - force-renew
          - disable-https
      domain:
        description: 'Specific domain (optional - leave blank for all domains)'
        required: false
        type: string
      dry_run:
        description: 'Perform dry run (test only)'
        required: false
        default: false
        type: boolean

  # schedule:
    # Auto-renew certificates every 12 hours
    # - cron: '0 */12 * * *'

env:
  REGISTRY: docker.io

jobs:
  validate-ssl-request:
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.set-action.outputs.action }}
      domain: ${{ steps.set-action.outputs.domain }}
      dry_run: ${{ steps.set-action.outputs.dry_run }}
    steps:
      - name: Determine SSL action
        id: set-action
        run: |
          # For scheduled runs, default to renewal check
          if [ "${{ github.event_name }}" = "schedule" ]; then
            ACTION="renew"
            DRY_RUN="false"
            DOMAIN=""
          else
            ACTION="${{ github.event.inputs.action }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"
            DOMAIN="${{ github.event.inputs.domain }}"
          fi
          
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "‚úÖ SSL action: $ACTION, Domain: ${DOMAIN:-'all'}, Dry run: $DRY_RUN"

  ssl-management:
    runs-on: ubuntu-latest
    needs: validate-ssl-request
    environment: shared
    
    steps:
      - name: SSL Certificate Management
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_SSH_PASSWORD }}
          script: |
            cd /opt/cach/shared
            
            ACTION="${{ needs.validate-ssl-request.outputs.action }}"
            DOMAIN="${{ needs.validate-ssl-request.outputs.domain }}"
            DRY_RUN="${{ needs.validate-ssl-request.outputs.dry_run }}"
            
            echo "üîí SSL Certificate Management"
            echo "Action: $ACTION"
            echo "Domain: ${DOMAIN:-'all domains'}"
            echo "Dry run: $DRY_RUN"
            
            # Ensure nginx is running for ACME challenges
            echo "üîç Ensuring nginx is running..."
            docker-compose -f docker-compose.shared.yml up -d nginx
            sleep 10
            
            # Check nginx status
            if ! docker ps | grep -q "cach_nginx.*Up"; then
              echo "‚ùå nginx is not running. Starting nginx..."
              docker-compose -f docker-compose.shared.yml up -d nginx
              sleep 15
              if ! docker ps | grep -q "cach_nginx.*Up"; then
                echo "‚ùå Failed to start nginx"
                exit 1
              fi
            fi
            echo "‚úÖ nginx is running"
            
            case "$ACTION" in
              "setup")
                echo "üîí Setting up SSL certificates..."
                
                if [ "$DRY_RUN" = "true" ]; then
                  echo "üß™ Performing dry run SSL setup..."
                  ./scripts/certbot/init-ssl.sh --dry-run
                else
                  echo "üöÄ Performing actual SSL setup..."
                  ./scripts/certbot/init-ssl.sh
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL setup completed successfully"
                  
                  # Switch to HTTPS configuration based on current environment
                  echo "üîÑ Switching to HTTPS nginx configuration..."
                  
                  # Determine current environment from existing config
                  if [ -f "./nginx/shared.conf" ] && grep -q "monitoring.cachconnect.co.ke" ./nginx/shared.conf 2>/dev/null && ! grep -q "api\." ./nginx/shared.conf 2>/dev/null; then
                    echo "Switching to shared (monitoring only) HTTPS configuration..."
                    cp ~/devops/nginx/nginx-https.conf ./nginx/nginx.conf
                    cp ~/devops/nginx/conf.d/shared-https.conf ./nginx/shared-ssl.conf
                    # Replace current config with HTTPS version
                    rm -f ./nginx/shared.conf
                    mv ./nginx/shared-ssl.conf ./nginx/shared.conf
                  elif grep -q "cachconnect.co.ke" ./nginx/*.conf 2>/dev/null; then
                    echo "Switching to production HTTPS configuration..."
                    cp ~/devops/nginx/nginx-https.conf ./nginx/nginx.conf
                    cp ~/devops/nginx/conf.d/production-https.conf ./nginx/production.conf
                    # Remove old HTTP config and replace with HTTPS
                    rm -f ./nginx/shared.conf ./nginx/production.conf
                    mv ./nginx/production.conf ./nginx/shared.conf
                  elif grep -q "staging.cachconnect.co.ke" ./nginx/*.conf 2>/dev/null; then
                    echo "Switching to staging HTTPS configuration..."
                    cp ~/devops/nginx/nginx-https.conf ./nginx/nginx.conf
                    cp ~/devops/nginx/conf.d/staging-https.conf ./nginx/staging.conf
                    # Replace current config with HTTPS version
                    rm -f ./nginx/shared.conf
                    mv ./nginx/staging.conf ./nginx/shared.conf
                  elif grep -q "sandbox.cachconnect.co.ke" ./nginx/*.conf 2>/dev/null; then
                    echo "Switching to sandbox HTTPS configuration..."
                    cp ~/devops/nginx/nginx-https.conf ./nginx/nginx.conf
                    cp ~/devops/nginx/conf.d/sandbox-https.conf ./nginx/sandbox.conf
                    # Replace current config with HTTPS version
                    rm -f ./nginx/shared.conf
                    mv ./nginx/sandbox.conf ./nginx/shared.conf
                  else
                    echo "Could not determine environment for SSL setup"
                    exit 1
                  fi
                  
                  # Reload nginx with HTTPS configuration
                  echo "üîÑ Reloading nginx with HTTPS configuration and certificates..."
                  docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload
                  
                  echo "üéâ HTTPS is now enabled for all services!"
                  echo "üìä HTTPS Access points:"
                  echo "   - Website: https://cachconnect.co.ke"
                  echo "   - API: https://api.cachconnect.co.ke"
                  echo "   - Admin: https://admin.cachconnect.co.ke"
                  echo "   - Agents: https://agents.cachconnect.co.ke"
                  echo "   - Grafana: https://monitoring.cachconnect.co.ke"
                  echo "   - Storage: https://storage.cachconnect.co.ke"
                else
                  echo "‚ùå SSL setup failed"
                  exit 1
                fi
                ;;
                
              "renew")
                echo "üîÑ Renewing SSL certificates..."
                
                if [ -n "$DOMAIN" ]; then
                  echo "üéØ Renewing certificate for specific domain: $DOMAIN"
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --cert-name "$DOMAIN"
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --cert-name "$DOMAIN"
                  fi
                else
                  echo "üîÑ Renewing all certificates..."
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew
                  fi
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL renewal completed successfully"
                  if [ "$DRY_RUN" != "true" ]; then
                    # Reload nginx to use renewed certificates
                    echo "üîÑ Reloading nginx with renewed certificates..."
                    docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload
                  fi
                else
                  echo "‚ùå SSL renewal failed"
                  exit 1
                fi
                ;;
                
              "force-renew")
                echo "‚ö° Force renewing SSL certificates..."
                
                if [ -n "$DOMAIN" ]; then
                  echo "üéØ Force renewing certificate for domain: $DOMAIN"
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --force-renewal --cert-name "$DOMAIN"
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --force-renewal --cert-name "$DOMAIN"
                  fi
                else
                  echo "‚ö° Force renewing all certificates..."
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --force-renewal
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --force-renewal
                  fi
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL force renewal completed successfully"
                  if [ "$DRY_RUN" != "true" ]; then
                    # Reload nginx to use renewed certificates
                    echo "üîÑ Reloading nginx with renewed certificates..."
                    docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload
                  fi
                else
                  echo "‚ùå SSL force renewal failed"
                  exit 1
                fi
                ;;
                
              "check-status")
                echo "üîç Checking SSL certificate status..."
                
                # List all certificates
                echo "üìã Current certificates:"
                docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt certbot/certbot certificates
                
                # Check expiration dates
                echo "üìÖ Certificate expiration check:"
                cert_dirs="/opt/cach/shared/ssl/letsencrypt/live/*"
                for cert_dir in $cert_dirs; do
                  if [ -d "$cert_dir" ]; then
                    domain=$(basename "$cert_dir")
                    cert_file="$cert_dir/fullchain.pem"
                    if [ -f "$cert_file" ]; then
                      echo "üîç Checking $domain..."
                      expiry=$(openssl x509 -enddate -noout -in "$cert_file" 2>/dev/null | cut -d= -f2)
                      if [ $? -eq 0 ]; then
                        echo "   üìÖ Expires: $expiry"
                        # Check if expires in next 30 days
                        expiry_epoch=$(date -d "$expiry" +%s 2>/dev/null)
                        current_epoch=$(date +%s)
                        days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))
                        if [ $days_until_expiry -lt 30 ]; then
                          echo "   ‚ö†Ô∏è  Certificate expires in $days_until_expiry days!"
                        else
                          echo "   ‚úÖ Certificate is valid for $days_until_expiry days"
                        fi
                      else
                        echo "   ‚ùå Invalid certificate file"
                      fi
                    else
                      echo "   ‚ùå Certificate file not found"
                    fi
                  fi
                done
                ;;
                
              "disable-https")
                echo "üîÑ Disabling HTTPS and switching back to HTTP-only configuration..."
                
                # Determine current environment and switch to appropriate HTTP config
                if [ -f "./nginx/shared.conf" ] && grep -q "monitoring.cachconnect.co.ke" ./nginx/shared.conf 2>/dev/null && ! grep -q "api\." ./nginx/shared.conf 2>/dev/null; then
                  echo "üìã Switching to shared HTTP-only nginx configuration..."
                  cp ~/devops/nginx/nginx-http.conf ./nginx/nginx.conf
                  cp ~/devops/nginx/conf.d/shared-http.conf ./nginx/shared-http-temp.conf
                  rm -f ./nginx/shared.conf
                  mv ./nginx/shared-http-temp.conf ./nginx/shared.conf
                elif grep -q "staging.cachconnect.co.ke" ./nginx/*.conf 2>/dev/null; then
                  echo "üìã Switching to staging HTTP-only nginx configuration..."
                  cp ~/devops/nginx/nginx-http.conf ./nginx/nginx.conf
                  cp ~/devops/nginx/conf.d/staging-http.conf ./nginx/staging-http-temp.conf
                  rm -f ./nginx/shared.conf
                  mv ./nginx/staging-http-temp.conf ./nginx/shared.conf
                elif grep -q "sandbox.cachconnect.co.ke" ./nginx/*.conf 2>/dev/null; then
                  echo "üìã Switching to sandbox HTTP-only nginx configuration..."
                  cp ~/devops/nginx/nginx-http.conf ./nginx/nginx.conf
                  cp ~/devops/nginx/conf.d/sandbox-http.conf ./nginx/sandbox-http-temp.conf
                  rm -f ./nginx/shared.conf
                  mv ./nginx/sandbox-http-temp.conf ./nginx/shared.conf
                else
                  echo "üìã Switching to production HTTP-only nginx configuration..."
                  cp ~/devops/nginx/nginx-http.conf ./nginx/nginx.conf
                  cp ~/devops/nginx/conf.d/production-http.conf ./nginx/production-http-temp.conf
                  rm -f ./nginx/shared.conf
                  mv ./nginx/production-http-temp.conf ./nginx/shared.conf
                fi
                
                # Reload nginx with HTTP-only configuration
                echo "üîÑ Reloading nginx with HTTP-only configuration..."
                docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload
                
                echo "‚úÖ HTTPS disabled - services now running on HTTP only"
                echo "üìä HTTP Access points (environment-specific):"
                echo "   - Monitoring: http://monitoring.cachconnect.co.ke"
                echo "   - Other services depend on deployed environment (production/staging/sandbox)"
                ;;
                
              *)
                echo "‚ùå Unknown SSL action: $ACTION"
                exit 1
                ;;
            esac
            
            echo "üéâ SSL management operation completed successfully!"

  notification:
    runs-on: ubuntu-latest
    needs: [validate-ssl-request, ssl-management]
    if: failure() || (github.event_name == 'schedule' && needs.validate-ssl-request.outputs.action == 'renew')
    
    steps:
      - name: Notify SSL Status
        run: |
          ACTION="${{ needs.validate-ssl-request.outputs.action }}"
          STATUS="${{ job.status }}"
          
          echo "üìß SSL Management Notification"
          echo "Action: $ACTION"
          echo "Status: $STATUS"
          echo "Timestamp: $(date)"
          
          # Here you could add email notification, Slack webhook, etc.
          # For now, just log the result
          if [ "$STATUS" = "failure" ]; then
            echo "‚ùå SSL management failed - manual intervention may be required"
          else
            echo "‚úÖ SSL management completed successfully"
          fi
