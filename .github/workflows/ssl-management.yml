name: SSL Certificate Management

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'SSL Action to perform'
        required: true
        default: 'setup'
        type: choice
        options:
          - setup
          - renew
          - check-status
          - force-renew
          - disable-https
      domain:
        description: 'Specific domain (optional - leave blank for all domains)'
        required: false
        type: string
      dry_run:
        description: 'Perform dry run (test only)'
        required: false
        default: false
        type: boolean

  # schedule:
    # Auto-renew certificates every 12 hours
    # - cron: '0 */12 * * *'

env:
  REGISTRY: docker.io

jobs:
  validate-ssl-request:
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.set-action.outputs.action }}
      domain: ${{ steps.set-action.outputs.domain }}
      dry_run: ${{ steps.set-action.outputs.dry_run }}
    steps:
      - name: Determine SSL action
        id: set-action
        run: |
          # For scheduled runs, default to renewal check
          if [ "${{ github.event_name }}" = "schedule" ]; then
            ACTION="renew"
            DRY_RUN="false"
            DOMAIN=""
          else
            ACTION="${{ github.event.inputs.action }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"
            DOMAIN="${{ github.event.inputs.domain }}"
          fi
          
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "✅ SSL action: $ACTION, Domain: ${DOMAIN:-'all'}, Dry run: $DRY_RUN"

  ssl-management:
    runs-on: ubuntu-latest
    needs: validate-ssl-request
    environment: shared
    
    steps:
      - name: SSL Certificate Management
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_SSH_PASSWORD }}
          script: |
            cd ~

            # Get latest devops configuration
            echo "📥 Downloading latest devops configuration..."
            if [ -d "devops" ]; then
              echo "Devops directory exists, updating..."
              cd devops
              git pull origin main
            else
              echo "Devops directory doesn't exist, cloning..."
              git clone https://github.com/Cach-Connect/devops.git devops
              cd devops
            fi

            # Create shared deployment directory if it doesn't exist
            cd /opt/cach || (mkdir -p /opt/cach && cd /opt/cach)
            
            if [ ! -d "shared" ]; then
              mkdir -p shared
            fi
            cd shared

            # Copy latest scripts to ensure we have the updated SSL script
            echo "📋 Updating SSL scripts..."
            rm -rf scripts && mkdir -p scripts
            cp -r ~/devops/scripts/* ./scripts/
            chmod +x scripts/*.sh scripts/certbot/*.sh

            # Copy latest nginx configuration structure
            echo "📋 Updating nginx configuration..."
            rm -rf nginx && mkdir -p nginx/conf.d
            cp -r ~/devops/nginx/conf.d/* ./nginx/conf.d/

            # Copy docker-compose file
            echo "📋 Updating docker-compose configuration..."
            cp ~/devops/docker-compose/docker-compose.shared.yml .

            # Ensure SSL directories exist
            echo "🔒 Setting up SSL directories..."
            mkdir -p ssl/letsencrypt/live ssl/letsencrypt/archive ssl/www
            
            ACTION="${{ needs.validate-ssl-request.outputs.action }}"
            DOMAIN="${{ needs.validate-ssl-request.outputs.domain }}"
            DRY_RUN="${{ needs.validate-ssl-request.outputs.dry_run }}"
            
            echo "🔒 SSL Certificate Management"
            echo "Action: $ACTION"
            echo "Domain: ${DOMAIN:-'all domains'}"
            echo "Dry run: $DRY_RUN"
            
            # Ensure nginx is running for ACME challenges
            echo "🔍 Ensuring nginx is running..."
            
            # Check if we're in a docker-compose subdirectory structure (local dev) or flat structure (server)
            if [ -d "docker-compose" ]; then
              echo "📁 Using docker-compose subdirectory structure"
              cd docker-compose
              COMPOSE_FILE="docker-compose.shared.yml"
            else
              echo "📁 Using flat directory structure"
              COMPOSE_FILE="docker-compose.shared.yml"
            fi
            
            docker-compose -f $COMPOSE_FILE up -d nginx
            
            # Return to original directory if we changed it
            if [ -d "../docker-compose" ]; then
              cd ..
            fi
            
            sleep 10
            
            # Check nginx status
            echo "🔍 Checking nginx container status..."
            docker ps --filter "name=cach_nginx" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Check if nginx container exists and is running (more flexible check)
            NGINX_STATUS=$(docker ps --filter "name=cach_nginx" --format "{{.Status}}" | head -1)
            if [ -z "$NGINX_STATUS" ] || [[ "$NGINX_STATUS" == *"Exited"* ]] || [[ "$NGINX_STATUS" == *"Dead"* ]]; then
              echo "❌ nginx is not running properly (Status: ${NGINX_STATUS:-'Not found'}). Starting nginx..."
              
              # Use same directory logic as above
              if [ -d "docker-compose" ]; then
                cd docker-compose
                COMPOSE_FILE="docker-compose.shared.yml"
              else
                COMPOSE_FILE="docker-compose.shared.yml"
              fi
              
              docker-compose -f $COMPOSE_FILE up -d nginx
              
              # Return to original directory if we changed it
              if [ -d "../docker-compose" ]; then
                cd ..
              fi
              sleep 15
              
              # Check final status
              FINAL_NGINX_STATUS=$(docker ps --filter "name=cach_nginx" --format "{{.Status}}" | head -1)
              if [ -z "$FINAL_NGINX_STATUS" ] || [[ "$FINAL_NGINX_STATUS" == *"Exited"* ]] || [[ "$FINAL_NGINX_STATUS" == *"Dead"* ]]; then
                echo "❌ Failed to start nginx properly"
                echo "🔍 Final nginx container status: ${FINAL_NGINX_STATUS:-'Not found'}"
                echo "🔍 Container logs:"
                docker logs cach_nginx --tail 20 2>/dev/null || echo "Could not retrieve logs"
                exit 1
              fi
            else
              echo "✅ nginx is already running (Status: $NGINX_STATUS)"
            fi
            
            echo "✅ nginx is ready for SSL operations"
            
            case "$ACTION" in
              "setup")
                echo "🔒 Setting up SSL certificates..."
                
                # Ensure we're using HTTP-only configs during SSL setup (to avoid SSL cert issues)
                echo "🔄 Temporarily switching to HTTP-only configuration for SSL setup..."
                if [ -d "./nginx/conf.d" ]; then
                  # Backup current config
                  cp -r ./nginx/conf.d ./nginx/conf.d-backup-before-ssl
                  
                  # Remove any HTTPS configs temporarily
                  find ./nginx/conf.d -name "*-https.conf" -delete 2>/dev/null || true
                  
                  # Restart nginx with HTTP-only configs
                  if [ -d "docker-compose" ]; then
                    cd docker-compose
                    COMPOSE_FILE="docker-compose.shared.yml"
                  else
                    COMPOSE_FILE="docker-compose.shared.yml"
                  fi
                  
                  echo "🔄 Restarting nginx with HTTP-only configuration..."
                  docker-compose -f $COMPOSE_FILE restart nginx
                  
                  # Return to original directory if we changed it
                  if [ -d "../docker-compose" ]; then
                    cd ..
                  fi
                  
                  sleep 5
                  echo "✅ nginx is now running with HTTP-only configuration"
                fi
                
                if [ "$DRY_RUN" = "true" ]; then
                  echo "🧪 Performing dry run SSL setup..."
                  ./scripts/certbot/init-ssl.sh --dry-run
                else
                  echo "🚀 Performing actual SSL setup..."
                  ./scripts/certbot/init-ssl.sh
                fi
                
                if [ $? -eq 0 ]; then
                  echo "✅ SSL setup completed successfully"
                  
                  # Switch to HTTPS configuration based on current environment
                  echo "🔄 Switching to HTTPS nginx configuration..."
                  
                  # Detect all running environments and enable HTTPS for all
                  DETECTED_ENVS=""
                  if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "production"; then
                    DETECTED_ENVS="$DETECTED_ENVS production"
                    echo "Detected production environment"
                  fi
                  if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "staging"; then
                    DETECTED_ENVS="$DETECTED_ENVS staging"
                    echo "Detected staging environment"
                  fi
                  if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "sandbox"; then
                    DETECTED_ENVS="$DETECTED_ENVS sandbox"
                    echo "Detected sandbox environment"
                  fi

                  echo "Enabling HTTPS for environments:$DETECTED_ENVS"

                  # Create temporary nginx config directory with HTTPS configs
                  echo "📁 Setting up HTTPS nginx configuration for detected environments..."
                  mkdir -p ./nginx/conf.d-https

                  # Always copy shared config
                  cp ./nginx/conf.d/shared-https.conf ./nginx/conf.d-https/

                  # Copy configs for each detected environment
                  for env in $DETECTED_ENVS; do
                    case "$env" in
                      "production")
                        cp ./nginx/conf.d/production-https.conf ./nginx/conf.d-https/
                        ;;
                      "staging") 
                        cp ./nginx/conf.d/staging-https.conf ./nginx/conf.d-https/
                        ;;
                      "sandbox")
                        cp ./nginx/conf.d/sandbox-https.conf ./nginx/conf.d-https/
                        ;;
                    esac
                  done
                  
                  # Create temporary nginx config directory with HTTPS configs
                  echo "📁 Setting up HTTPS nginx configuration for $ENV_TYPE environment..."
                  
                  # Backup current HTTP config directory first (before any changes)
                  echo "💾 Backing up current HTTP configuration..."
                  cp -r ./nginx/conf.d ./nginx/conf.d-http-backup
                  
                  # Create a new temp directory for HTTPS configs
                  mkdir -p ./nginx/conf.d-https-temp
                  
                  # Copy HTTPS configurations based on environment (with error checking)
                  echo "📋 Copying HTTPS configurations..."
                  if [ -f "./nginx/conf.d/shared-https.conf" ]; then
                    cp ./nginx/conf.d/shared-https.conf ./nginx/conf.d-https-temp/
                  else
                    echo "⚠️  shared-https.conf not found, using HTTP version as fallback"
                    # Use HTTP version as fallback if HTTPS doesn't exist
                    if [ -f "./nginx/conf.d/shared-http.conf" ]; then
                      cp ./nginx/conf.d/shared-http.conf ./nginx/conf.d-https-temp/
                    fi
                  fi
                  
                  case "$ENV_TYPE" in
                    "production")
                      if [ -f "./nginx/conf.d/production-https.conf" ]; then
                        cp ./nginx/conf.d/production-https.conf ./nginx/conf.d-https-temp/
                      else
                        echo "⚠️  production-https.conf not found, keeping HTTP config"
                        # Copy HTTP config as fallback
                        cp ./nginx/conf.d/production-http.conf ./nginx/conf.d-https-temp/
                      fi
                      ;;
                    "staging") 
                      if [ -f "./nginx/conf.d/staging-https.conf" ]; then
                        cp ./nginx/conf.d/staging-https.conf ./nginx/conf.d-https-temp/
                      else
                        echo "⚠️  staging-https.conf not found, keeping HTTP config"
                        cp ./nginx/conf.d/staging-http.conf ./nginx/conf.d-https-temp/
                      fi
                      ;;
                    "sandbox")
                      if [ -f "./nginx/conf.d/sandbox-https.conf" ]; then
                        cp ./nginx/conf.d/sandbox-https.conf ./nginx/conf.d-https-temp/
                      else
                        echo "⚠️  sandbox-https.conf not found, keeping HTTP config"
                        cp ./nginx/conf.d/sandbox-http.conf ./nginx/conf.d-https-temp/
                      fi
                      ;;
                  esac
                  
                  # Use Docker to stop nginx and switch configs (avoids permission issues)
                  echo "🔄 Stopping nginx to switch configurations..."
                  if [ -d "docker-compose" ]; then
                    cd docker-compose
                    COMPOSE_FILE="docker-compose.shared.yml"
                  else
                    COMPOSE_FILE="docker-compose.shared.yml"
                  fi
                  
                  docker-compose -f $COMPOSE_FILE stop nginx
                  
                  # Return to original directory if we changed it
                  if [ -d "../docker-compose" ]; then
                    cd ..
                  fi
                  
                  # Now switch to https configs
                  echo "🔄 Switching to HTTPS configurations..."
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-https-temp ./nginx/conf.d
                  
                  # Start nginx with new HTTPS configuration
                  echo "🔄 Starting nginx with HTTPS configuration and certificates..."
                  
                  # nginx is already stopped from above, just start it
                  docker-compose -f $COMPOSE_FILE up -d nginx
                  
                  # Wait for nginx to start
                  sleep 10
                  
                  # Verify nginx started successfully with HTTPS
                  echo "🔍 Verifying nginx HTTPS configuration..."
                  if docker ps --filter "name=cach_nginx" --filter "status=running" --format "{{.Names}}" | grep -q "cach_nginx"; then
                    echo "✅ nginx is running with HTTPS configuration"
                    # Test configuration
                    if docker exec cach_nginx nginx -t >/dev/null 2>&1; then
                      echo "✅ nginx configuration is valid"
                    else
                      echo "⚠️  nginx configuration test failed - checking logs..."
                      docker logs cach_nginx --tail 10
                    fi
                  else
                    echo "❌ nginx failed to start with HTTPS configuration"
                    echo "🔍 nginx logs:"
                    docker logs cach_nginx --tail 20 2>/dev/null || echo "Could not retrieve logs"
                    exit 1
                  fi
                  
                  echo "🎉 HTTPS is now enabled for all services!"
                  echo "📊 HTTPS Access points:"
                  echo "   - Website: https://cachconnect.co.ke"
                  echo "   - API: https://api.cachconnect.co.ke"
                  echo "   - Admin: https://admin.cachconnect.co.ke"
                  echo "   - Agents: https://agents.cachconnect.co.ke"
                  echo "   - Grafana: https://monitoring.cachconnect.co.ke"
                  echo "   - Storage: https://storage.cachconnect.co.ke"
                else
                  echo "❌ SSL setup failed"
                  exit 1
                fi
                ;;
                
              "renew")
                echo "🔄 Renewing SSL certificates..."
                
                if [ -n "$DOMAIN" ]; then
                  echo "🎯 Renewing certificate for specific domain: $DOMAIN"
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --cert-name "$DOMAIN"
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --cert-name "$DOMAIN"
                  fi
                else
                  echo "🔄 Renewing all certificates..."
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew
                  fi
                fi
                
                if [ $? -eq 0 ]; then
                  echo "✅ SSL renewal completed successfully"
                  if [ "$DRY_RUN" != "true" ]; then
                    # Reload nginx to use renewed certificates
                    echo "🔄 Reloading nginx with renewed certificates..."
                    # Use directory detection for nginx reload
                    if [ -d "docker-compose" ]; then
                      cd docker-compose && docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload && cd ..
                    else
                    docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload
                    fi
                  fi
                else
                  echo "❌ SSL renewal failed"
                  exit 1
                fi
                ;;
                
              "force-renew")
                echo "⚡ Force renewing SSL certificates..."
                
                if [ -n "$DOMAIN" ]; then
                  echo "🎯 Force renewing certificate for domain: $DOMAIN"
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --force-renewal --cert-name "$DOMAIN"
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --force-renewal --cert-name "$DOMAIN"
                  fi
                else
                  echo "⚡ Force renewing all certificates..."
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --force-renewal
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --force-renewal
                  fi
                fi
                
                if [ $? -eq 0 ]; then
                  echo "✅ SSL force renewal completed successfully"
                  if [ "$DRY_RUN" != "true" ]; then
                    # Reload nginx to use renewed certificates
                    echo "🔄 Reloading nginx with renewed certificates..."
                    # Use directory detection for nginx reload
                    if [ -d "docker-compose" ]; then
                      cd docker-compose && docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload && cd ..
                    else
                    docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload
                    fi
                  fi
                else
                  echo "❌ SSL force renewal failed"
                  exit 1
                fi
                ;;
                
              "check-status")
                echo "🔍 Checking SSL certificate status..."
                
                # List all certificates
                echo "📋 Current certificates:"
                docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt certbot/certbot certificates
                
                # Check expiration dates
                echo "📅 Certificate expiration check:"
                cert_dirs="/opt/cach/shared/ssl/letsencrypt/live/*"
                for cert_dir in $cert_dirs; do
                  if [ -d "$cert_dir" ]; then
                    domain=$(basename "$cert_dir")
                    cert_file="$cert_dir/fullchain.pem"
                    if [ -f "$cert_file" ]; then
                      echo "🔍 Checking $domain..."
                      expiry=$(openssl x509 -enddate -noout -in "$cert_file" 2>/dev/null | cut -d= -f2)
                      if [ $? -eq 0 ]; then
                        echo "   📅 Expires: $expiry"
                        # Check if expires in next 30 days
                        expiry_epoch=$(date -d "$expiry" +%s 2>/dev/null)
                        current_epoch=$(date +%s)
                        days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))
                        if [ $days_until_expiry -lt 30 ]; then
                          echo "   ⚠️  Certificate expires in $days_until_expiry days!"
                        else
                          echo "   ✅ Certificate is valid for $days_until_expiry days"
                        fi
                      else
                        echo "   ❌ Invalid certificate file"
                      fi
                    else
                      echo "   ❌ Certificate file not found"
                    fi
                  fi
                done
                ;;
                
              "disable-https")
                echo "🔄 Disabling HTTPS and switching back to HTTP-only configuration..."
                
                # Check if we have a backup of HTTP configs
                if [ -d "./nginx/conf.d-http-backup" ]; then
                  echo "📋 Restoring HTTP configuration from backup..."
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-http-backup ./nginx/conf.d
                else
                  echo "📋 No backup found, recreating HTTP configuration from source..."
                  
                  # Check which environment is currently deployed
                  if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "production"; then
                    ENV_TYPE="production"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "staging"; then
                    ENV_TYPE="staging"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "sandbox"; then
                    ENV_TYPE="sandbox"
                  else
                    ENV_TYPE="shared"
                  fi
                  
                  # Create HTTP-only config directory
                  mkdir -p ./nginx/conf.d-http
                  
                  # Copy HTTP configurations based on environment
                  cp ./nginx/conf.d/shared-http.conf ./nginx/conf.d-http/
                  case "$ENV_TYPE" in
                    "production")
                      cp ./nginx/conf.d/production-http.conf ./nginx/conf.d-http/
                      ;;
                    "staging")
                      cp ./nginx/conf.d/staging-http.conf ./nginx/conf.d-http/
                      ;;
                    "sandbox")
                      cp ./nginx/conf.d/sandbox-http.conf ./nginx/conf.d-http/
                      ;;
                  esac
                  
                  # Replace with HTTP configurations
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-http ./nginx/conf.d
                fi
                
                # Restart nginx with HTTP-only configuration
                echo "🔄 Restarting nginx with HTTP-only configuration..."
                
                # Use same directory detection logic
                if [ -d "docker-compose" ]; then
                  cd docker-compose
                  COMPOSE_FILE="docker-compose.shared.yml"
                else
                  COMPOSE_FILE="docker-compose.shared.yml"
                fi
                
                docker-compose -f $COMPOSE_FILE stop nginx
                sleep 5
                docker-compose -f $COMPOSE_FILE up -d nginx
                
                # Return to original directory if we changed it
                if [ -d "../docker-compose" ]; then
                  cd ..
                fi
                
                echo "✅ HTTPS disabled - services now running on HTTP only"
                echo "📊 HTTP Access points (environment-specific):"
                echo "   - Monitoring: http://monitoring.cachconnect.co.ke"
                echo "   - Other services depend on deployed environment (production/staging/sandbox)"
                ;;
                
              *)
                echo "❌ Unknown SSL action: $ACTION"
                exit 1
                ;;
            esac
            
            echo "🎉 SSL management operation completed successfully!"

  notification:
    runs-on: ubuntu-latest
    needs: [validate-ssl-request, ssl-management]
    if: failure() || (github.event_name == 'schedule' && needs.validate-ssl-request.outputs.action == 'renew')
    
    steps:
      - name: Notify SSL Status
        run: |
          ACTION="${{ needs.validate-ssl-request.outputs.action }}"
          STATUS="${{ job.status }}"
          
          echo "📧 SSL Management Notification"
          echo "Action: $ACTION"
          echo "Status: $STATUS"
          echo "Timestamp: $(date)"
          
          # Here you could add email notification, Slack webhook, etc.
          # For now, just log the result
          if [ "$STATUS" = "failure" ]; then
            echo "❌ SSL management failed - manual intervention may be required"
          else
            echo "✅ SSL management completed successfully"
          fi
