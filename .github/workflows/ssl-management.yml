name: SSL Certificate Management

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'SSL Action to perform'
        required: true
        default: 'setup'
        type: choice
        options:
          - setup
          - renew
          - check-status
          - force-renew
          - disable-https
      domain:
        description: 'Specific domain (optional - leave blank for all domains)'
        required: false
        type: string
      dry_run:
        description: 'Perform dry run (test only)'
        required: false
        default: false
        type: boolean

  # schedule:
    # Auto-renew certificates every 12 hours
    # - cron: '0 */12 * * *'

env:
  REGISTRY: docker.io

jobs:
  validate-ssl-request:
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.set-action.outputs.action }}
      domain: ${{ steps.set-action.outputs.domain }}
      dry_run: ${{ steps.set-action.outputs.dry_run }}
    steps:
      - name: Determine SSL action
        id: set-action
        run: |
          # For scheduled runs, default to renewal check
          if [ "${{ github.event_name }}" = "schedule" ]; then
            ACTION="renew"
            DRY_RUN="false"
            DOMAIN=""
          else
            ACTION="${{ github.event.inputs.action }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"
            DOMAIN="${{ github.event.inputs.domain }}"
          fi
          
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "‚úÖ SSL action: $ACTION, Domain: ${DOMAIN:-'all'}, Dry run: $DRY_RUN"

  ssl-management:
    runs-on: ubuntu-latest
    needs: validate-ssl-request
    environment: shared
    
    steps:
      - name: SSL Certificate Management
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_SSH_PASSWORD }}
          script: |
            cd ~

            # Get latest devops configuration
            echo "üì• Downloading latest devops configuration..."
            if [ -d "devops" ]; then
              echo "Devops directory exists, updating..."
              cd devops
              git pull origin main
            else
              echo "Devops directory doesn't exist, cloning..."
              git clone https://github.com/Cach-Connect/devops.git devops
              cd devops
            fi

            # Create shared deployment directory if it doesn't exist
            cd /opt/cach || (mkdir -p /opt/cach && cd /opt/cach)
            
            if [ ! -d "shared" ]; then
              mkdir -p shared
            fi
            cd shared

            # Copy latest scripts to ensure we have the updated SSL script
            echo "üìã Updating SSL scripts..."
            rm -rf scripts && mkdir -p scripts
            cp -r ~/devops/scripts/* ./scripts/
            chmod +x scripts/*.sh scripts/certbot/*.sh

            # Copy latest nginx configuration structure
            echo "üìã Updating nginx configuration..."
            rm -rf nginx && mkdir -p nginx/conf.d
            cp -r ~/devops/nginx/conf.d/* ./nginx/conf.d/

            # Copy docker-compose file
            echo "üìã Updating docker-compose configuration..."
            cp ~/devops/docker-compose/docker-compose.shared.yml .

            # Ensure SSL directories exist
            echo "üîí Setting up SSL directories..."
            mkdir -p ssl/letsencrypt/live ssl/letsencrypt/archive ssl/www
            
            ACTION="${{ needs.validate-ssl-request.outputs.action }}"
            DOMAIN="${{ needs.validate-ssl-request.outputs.domain }}"
            DRY_RUN="${{ needs.validate-ssl-request.outputs.dry_run }}"
            
            echo "üîí SSL Certificate Management"
            echo "Action: $ACTION"
            echo "Domain: ${DOMAIN:-'all domains'}"
            echo "Dry run: $DRY_RUN"
            
            # Ensure nginx is running for ACME challenges
            echo "üîç Ensuring nginx is running..."
            
            # Check if we're in a docker-compose subdirectory structure (local dev) or flat structure (server)
            if [ -d "docker-compose" ]; then
              echo "üìÅ Using docker-compose subdirectory structure"
              cd docker-compose
              COMPOSE_FILE="docker-compose.shared.yml"
            else
              echo "üìÅ Using flat directory structure"
              COMPOSE_FILE="docker-compose.shared.yml"
            fi
            
            docker-compose -f $COMPOSE_FILE up -d nginx
            
            # Return to original directory if we changed it
            if [ -d "../docker-compose" ]; then
              cd ..
            fi
            
            sleep 10
            
            # Check nginx status
            echo "üîç Checking nginx container status..."
            docker ps --filter "name=cach_nginx" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            
            # Check if nginx container exists and is running (more flexible check)
            NGINX_STATUS=$(docker ps --filter "name=cach_nginx" --format "{{.Status}}" | head -1)
            if [ -z "$NGINX_STATUS" ] || [[ "$NGINX_STATUS" == *"Exited"* ]] || [[ "$NGINX_STATUS" == *"Dead"* ]]; then
              echo "‚ùå nginx is not running properly (Status: ${NGINX_STATUS:-'Not found'}). Starting nginx..."
              
              # Use same directory logic as above
              if [ -d "docker-compose" ]; then
                cd docker-compose
                COMPOSE_FILE="docker-compose.shared.yml"
              else
                COMPOSE_FILE="docker-compose.shared.yml"
              fi
              
              docker-compose -f $COMPOSE_FILE up -d nginx
              
              # Return to original directory if we changed it
              if [ -d "../docker-compose" ]; then
                cd ..
              fi
              sleep 15
              
              # Check final status
              FINAL_NGINX_STATUS=$(docker ps --filter "name=cach_nginx" --format "{{.Status}}" | head -1)
              if [ -z "$FINAL_NGINX_STATUS" ] || [[ "$FINAL_NGINX_STATUS" == *"Exited"* ]] || [[ "$FINAL_NGINX_STATUS" == *"Dead"* ]]; then
                echo "‚ùå Failed to start nginx properly"
                echo "üîç Final nginx container status: ${FINAL_NGINX_STATUS:-'Not found'}"
                echo "üîç Container logs:"
                docker logs cach_nginx --tail 20 2>/dev/null || echo "Could not retrieve logs"
                exit 1
              fi
            else
              echo "‚úÖ nginx is already running (Status: $NGINX_STATUS)"
            fi
            
            echo "‚úÖ nginx is ready for SSL operations"
            
            case "$ACTION" in
              "setup")
                echo "üîí Setting up SSL certificates..."
                
                # Ensure we're using HTTP-only configs during SSL setup (to avoid SSL cert issues)
                echo "üîÑ Temporarily switching to HTTP-only configuration for SSL setup..."
                if [ -d "./nginx/conf.d" ]; then
                  # Backup current config
                  cp -r ./nginx/conf.d ./nginx/conf.d-backup-before-ssl
                  
                  # Remove any HTTPS configs temporarily
                  find ./nginx/conf.d -name "*-https.conf" -delete 2>/dev/null || true
                  
                  # Restart nginx with HTTP-only configs
                  if [ -d "docker-compose" ]; then
                    cd docker-compose
                    COMPOSE_FILE="docker-compose.shared.yml"
                  else
                    COMPOSE_FILE="docker-compose.shared.yml"
                  fi
                  
                  echo "üîÑ Restarting nginx with HTTP-only configuration..."
                  docker-compose -f $COMPOSE_FILE restart nginx
                  
                  # Return to original directory if we changed it
                  if [ -d "../docker-compose" ]; then
                    cd ..
                  fi
                  
                  sleep 5
                  echo "‚úÖ nginx is now running with HTTP-only configuration"
                fi
                
                if [ "$DRY_RUN" = "true" ]; then
                  echo "üß™ Performing dry run SSL setup..."
                  ./scripts/certbot/init-ssl.sh --dry-run
                else
                  echo "üöÄ Performing actual SSL setup..."
                  ./scripts/certbot/init-ssl.sh
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL setup completed successfully"
                  
                  # Switch to HTTPS configuration based on current environment
                  echo "üîÑ Switching to HTTPS nginx configuration..."
                  
                  # Check which environment is currently deployed
                  if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "production"; then
                    echo "Detected production environment - enabling HTTPS for production"
                    ENV_TYPE="production"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "staging"; then
                    echo "Detected staging environment - enabling HTTPS for staging" 
                    ENV_TYPE="staging"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "sandbox"; then
                    echo "Detected sandbox environment - enabling HTTPS for sandbox"
                    ENV_TYPE="sandbox" 
                  else
                    echo "No specific environment detected - defaulting to shared monitoring"
                    ENV_TYPE="shared"
                  fi
                  
                  # Create temporary nginx config directory with HTTPS configs
                  echo "üìÅ Setting up HTTPS nginx configuration for $ENV_TYPE environment..."
                  mkdir -p ./nginx/conf.d-https
                  
                  # Copy HTTPS configurations based on environment
                  cp ./nginx/conf.d/shared-https.conf ./nginx/conf.d-https/
                  case "$ENV_TYPE" in
                    "production")
                      cp ./nginx/conf.d/production-https.conf ./nginx/conf.d-https/
                      ;;
                    "staging") 
                      cp ./nginx/conf.d/staging-https.conf ./nginx/conf.d-https/
                      ;;
                    "sandbox")
                      cp ./nginx/conf.d/sandbox-https.conf ./nginx/conf.d-https/
                      ;;
                  esac
                  
                  echo "‚úÖ HTTPS configurations prepared for $ENV_TYPE environment"
                  
                  # Backup current HTTP config directory
                  echo "üíæ Backing up current HTTP configuration..."
                  cp -r ./nginx/conf.d ./nginx/conf.d-http-backup
                  
                  # Replace with HTTPS configurations
                  echo "üîÑ Switching to HTTPS configurations..."
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-https ./nginx/conf.d
                  
                  # Restart nginx container to load new configurations
                  echo "üîÑ Restarting nginx with HTTPS configuration and certificates..."
                  
                  # Use same directory detection logic
                  if [ -d "docker-compose" ]; then
                    cd docker-compose
                    COMPOSE_FILE="docker-compose.shared.yml"
                  else
                    COMPOSE_FILE="docker-compose.shared.yml"
                  fi
                  
                  docker-compose -f $COMPOSE_FILE stop nginx
                  sleep 5
                  docker-compose -f $COMPOSE_FILE up -d nginx
                  
                  # Return to original directory if we changed it
                  if [ -d "../docker-compose" ]; then
                    cd ..
                  fi
                  
                  echo "üéâ HTTPS is now enabled for all services!"
                  echo "üìä HTTPS Access points:"
                  echo "   - Website: https://cachconnect.co.ke"
                  echo "   - API: https://api.cachconnect.co.ke"
                  echo "   - Admin: https://admin.cachconnect.co.ke"
                  echo "   - Agents: https://agents.cachconnect.co.ke"
                  echo "   - Grafana: https://monitoring.cachconnect.co.ke"
                  echo "   - Storage: https://storage.cachconnect.co.ke"
                else
                  echo "‚ùå SSL setup failed"
                  exit 1
                fi
                ;;
                
              "renew")
                echo "üîÑ Renewing SSL certificates..."
                
                if [ -n "$DOMAIN" ]; then
                  echo "üéØ Renewing certificate for specific domain: $DOMAIN"
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --cert-name "$DOMAIN"
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --cert-name "$DOMAIN"
                  fi
                else
                  echo "üîÑ Renewing all certificates..."
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew
                  fi
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL renewal completed successfully"
                  if [ "$DRY_RUN" != "true" ]; then
                    # Reload nginx to use renewed certificates
                    echo "üîÑ Reloading nginx with renewed certificates..."
                    # Use directory detection for nginx reload
                    if [ -d "docker-compose" ]; then
                      cd docker-compose && docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload && cd ..
                    else
                    docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload
                    fi
                  fi
                else
                  echo "‚ùå SSL renewal failed"
                  exit 1
                fi
                ;;
                
              "force-renew")
                echo "‚ö° Force renewing SSL certificates..."
                
                if [ -n "$DOMAIN" ]; then
                  echo "üéØ Force renewing certificate for domain: $DOMAIN"
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --force-renewal --cert-name "$DOMAIN"
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --force-renewal --cert-name "$DOMAIN"
                  fi
                else
                  echo "‚ö° Force renewing all certificates..."
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --force-renewal
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --force-renewal
                  fi
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL force renewal completed successfully"
                  if [ "$DRY_RUN" != "true" ]; then
                    # Reload nginx to use renewed certificates
                    echo "üîÑ Reloading nginx with renewed certificates..."
                    # Use directory detection for nginx reload
                    if [ -d "docker-compose" ]; then
                      cd docker-compose && docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload && cd ..
                    else
                    docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload
                    fi
                  fi
                else
                  echo "‚ùå SSL force renewal failed"
                  exit 1
                fi
                ;;
                
              "check-status")
                echo "üîç Checking SSL certificate status..."
                
                # List all certificates
                echo "üìã Current certificates:"
                docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt certbot/certbot certificates
                
                # Check expiration dates
                echo "üìÖ Certificate expiration check:"
                cert_dirs="/opt/cach/shared/ssl/letsencrypt/live/*"
                for cert_dir in $cert_dirs; do
                  if [ -d "$cert_dir" ]; then
                    domain=$(basename "$cert_dir")
                    cert_file="$cert_dir/fullchain.pem"
                    if [ -f "$cert_file" ]; then
                      echo "üîç Checking $domain..."
                      expiry=$(openssl x509 -enddate -noout -in "$cert_file" 2>/dev/null | cut -d= -f2)
                      if [ $? -eq 0 ]; then
                        echo "   üìÖ Expires: $expiry"
                        # Check if expires in next 30 days
                        expiry_epoch=$(date -d "$expiry" +%s 2>/dev/null)
                        current_epoch=$(date +%s)
                        days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))
                        if [ $days_until_expiry -lt 30 ]; then
                          echo "   ‚ö†Ô∏è  Certificate expires in $days_until_expiry days!"
                        else
                          echo "   ‚úÖ Certificate is valid for $days_until_expiry days"
                        fi
                      else
                        echo "   ‚ùå Invalid certificate file"
                      fi
                    else
                      echo "   ‚ùå Certificate file not found"
                    fi
                  fi
                done
                ;;
                
              "disable-https")
                echo "üîÑ Disabling HTTPS and switching back to HTTP-only configuration..."
                
                # Check if we have a backup of HTTP configs
                if [ -d "./nginx/conf.d-http-backup" ]; then
                  echo "üìã Restoring HTTP configuration from backup..."
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-http-backup ./nginx/conf.d
                else
                  echo "üìã No backup found, recreating HTTP configuration from source..."
                  
                  # Check which environment is currently deployed
                  if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "production"; then
                    ENV_TYPE="production"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "staging"; then
                    ENV_TYPE="staging"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "sandbox"; then
                    ENV_TYPE="sandbox"
                  else
                    ENV_TYPE="shared"
                  fi
                  
                  # Create HTTP-only config directory
                  mkdir -p ./nginx/conf.d-http
                  
                  # Copy HTTP configurations based on environment
                  cp ./nginx/conf.d/shared-http.conf ./nginx/conf.d-http/
                  case "$ENV_TYPE" in
                    "production")
                      cp ./nginx/conf.d/production-http.conf ./nginx/conf.d-http/
                      ;;
                    "staging")
                      cp ./nginx/conf.d/staging-http.conf ./nginx/conf.d-http/
                      ;;
                    "sandbox")
                      cp ./nginx/conf.d/sandbox-http.conf ./nginx/conf.d-http/
                      ;;
                  esac
                  
                  # Replace with HTTP configurations
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-http ./nginx/conf.d
                fi
                
                # Restart nginx with HTTP-only configuration
                echo "üîÑ Restarting nginx with HTTP-only configuration..."
                
                # Use same directory detection logic
                if [ -d "docker-compose" ]; then
                  cd docker-compose
                  COMPOSE_FILE="docker-compose.shared.yml"
                else
                  COMPOSE_FILE="docker-compose.shared.yml"
                fi
                
                docker-compose -f $COMPOSE_FILE stop nginx
                sleep 5
                docker-compose -f $COMPOSE_FILE up -d nginx
                
                # Return to original directory if we changed it
                if [ -d "../docker-compose" ]; then
                  cd ..
                fi
                
                echo "‚úÖ HTTPS disabled - services now running on HTTP only"
                echo "üìä HTTP Access points (environment-specific):"
                echo "   - Monitoring: http://monitoring.cachconnect.co.ke"
                echo "   - Other services depend on deployed environment (production/staging/sandbox)"
                ;;
                
              *)
                echo "‚ùå Unknown SSL action: $ACTION"
                exit 1
                ;;
            esac
            
            echo "üéâ SSL management operation completed successfully!"

  notification:
    runs-on: ubuntu-latest
    needs: [validate-ssl-request, ssl-management]
    if: failure() || (github.event_name == 'schedule' && needs.validate-ssl-request.outputs.action == 'renew')
    
    steps:
      - name: Notify SSL Status
        run: |
          ACTION="${{ needs.validate-ssl-request.outputs.action }}"
          STATUS="${{ job.status }}"
          
          echo "üìß SSL Management Notification"
          echo "Action: $ACTION"
          echo "Status: $STATUS"
          echo "Timestamp: $(date)"
          
          # Here you could add email notification, Slack webhook, etc.
          # For now, just log the result
          if [ "$STATUS" = "failure" ]; then
            echo "‚ùå SSL management failed - manual intervention may be required"
          else
            echo "‚úÖ SSL management completed successfully"
          fi
