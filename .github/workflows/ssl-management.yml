name: SSL Certificate Management

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'SSL Action to perform'
        required: true
        default: 'setup'
        type: choice
        options:
          - setup
          - renew
          - check-status
          - force-renew
          - disable-https
      domain:
        description: 'Specific domain (optional - leave blank for all domains)'
        required: false
        type: string
      dry_run:
        description: 'Perform dry run (test only)'
        required: false
        default: false
        type: boolean

  # schedule:
    # Auto-renew certificates every 12 hours
    # - cron: '0 */12 * * *'

env:
  REGISTRY: docker.io

jobs:
  validate-ssl-request:
    runs-on: ubuntu-latest
    outputs:
      action: ${{ steps.set-action.outputs.action }}
      domain: ${{ steps.set-action.outputs.domain }}
      dry_run: ${{ steps.set-action.outputs.dry_run }}
    steps:
      - name: Determine SSL action
        id: set-action
        run: |
          # For scheduled runs, default to renewal check
          if [ "${{ github.event_name }}" = "schedule" ]; then
            ACTION="renew"
            DRY_RUN="false"
            DOMAIN=""
          else
            ACTION="${{ github.event.inputs.action }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"
            DOMAIN="${{ github.event.inputs.domain }}"
          fi
          
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "‚úÖ SSL action: $ACTION, Domain: ${DOMAIN:-'all'}, Dry run: $DRY_RUN"

  ssl-management:
    runs-on: ubuntu-latest
    needs: validate-ssl-request
    environment: shared
    
    steps:
      - name: SSL Certificate Management
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_SSH_PASSWORD }}
          script: |
            cd /opt/cach/shared
            
            ACTION="${{ needs.validate-ssl-request.outputs.action }}"
            DOMAIN="${{ needs.validate-ssl-request.outputs.domain }}"
            DRY_RUN="${{ needs.validate-ssl-request.outputs.dry_run }}"
            
            echo "üîí SSL Certificate Management"
            echo "Action: $ACTION"
            echo "Domain: ${DOMAIN:-'all domains'}"
            echo "Dry run: $DRY_RUN"
            
            # Ensure nginx is running for ACME challenges
            echo "üîç Ensuring nginx is running..."
            cd docker-compose
            docker-compose -f docker-compose.shared.yml up -d nginx
            cd ..
            sleep 10
            
            # Check nginx status
            if ! docker ps | grep -q "cach_nginx.*Up"; then
              echo "‚ùå nginx is not running. Starting nginx..."
              cd docker-compose
              docker-compose -f docker-compose.shared.yml up -d nginx
              cd ..
              sleep 15
              if ! docker ps | grep -q "cach_nginx.*Up"; then
                echo "‚ùå Failed to start nginx"
                exit 1
              fi
            fi
            echo "‚úÖ nginx is running"
            
            case "$ACTION" in
              "setup")
                echo "üîí Setting up SSL certificates..."
                
                if [ "$DRY_RUN" = "true" ]; then
                  echo "üß™ Performing dry run SSL setup..."
                  ./scripts/certbot/init-ssl.sh --dry-run
                else
                  echo "üöÄ Performing actual SSL setup..."
                  ./scripts/certbot/init-ssl.sh
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL setup completed successfully"
                  
                  # Switch to HTTPS configuration based on current environment
                  echo "üîÑ Switching to HTTPS nginx configuration..."
                  
                  # Check which environment is currently deployed
                  if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "production"; then
                    echo "Detected production environment - enabling HTTPS for production"
                    ENV_TYPE="production"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "staging"; then
                    echo "Detected staging environment - enabling HTTPS for staging" 
                    ENV_TYPE="staging"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "sandbox"; then
                    echo "Detected sandbox environment - enabling HTTPS for sandbox"
                    ENV_TYPE="sandbox" 
                  else
                    echo "No specific environment detected - defaulting to shared monitoring"
                    ENV_TYPE="shared"
                  fi
                  
                  # Create temporary nginx config directory with HTTPS configs
                  echo "üìÅ Setting up HTTPS nginx configuration for $ENV_TYPE environment..."
                  mkdir -p ./nginx/conf.d-https
                  
                  # Copy HTTPS configurations based on environment
                  cp ./nginx/conf.d/shared-https.conf ./nginx/conf.d-https/
                  case "$ENV_TYPE" in
                    "production")
                      cp ./nginx/conf.d/production-https.conf ./nginx/conf.d-https/
                      ;;
                    "staging") 
                      cp ./nginx/conf.d/staging-https.conf ./nginx/conf.d-https/
                      ;;
                    "sandbox")
                      cp ./nginx/conf.d/sandbox-https.conf ./nginx/conf.d-https/
                      ;;
                  esac
                  
                  # Backup current HTTP config directory
                  echo "üíæ Backing up current HTTP configuration..."
                  cp -r ./nginx/conf.d ./nginx/conf.d-http-backup
                  
                  # Replace with HTTPS configurations
                  echo "üîÑ Switching to HTTPS configurations..."
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-https ./nginx/conf.d
                  
                  # Restart nginx container to load new configurations
                  echo "üîÑ Restarting nginx with HTTPS configuration and certificates..."
                  cd docker-compose
                  docker-compose -f docker-compose.shared.yml stop nginx
                  sleep 5
                  docker-compose -f docker-compose.shared.yml up -d nginx
                  cd ..
                  
                  echo "üéâ HTTPS is now enabled for all services!"
                  echo "üìä HTTPS Access points:"
                  echo "   - Website: https://cachconnect.co.ke"
                  echo "   - API: https://api.cachconnect.co.ke"
                  echo "   - Admin: https://admin.cachconnect.co.ke"
                  echo "   - Agents: https://agents.cachconnect.co.ke"
                  echo "   - Grafana: https://monitoring.cachconnect.co.ke"
                  echo "   - Storage: https://storage.cachconnect.co.ke"
                else
                  echo "‚ùå SSL setup failed"
                  exit 1
                fi
                ;;
                
              "renew")
                echo "üîÑ Renewing SSL certificates..."
                
                if [ -n "$DOMAIN" ]; then
                  echo "üéØ Renewing certificate for specific domain: $DOMAIN"
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --cert-name "$DOMAIN"
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --cert-name "$DOMAIN"
                  fi
                else
                  echo "üîÑ Renewing all certificates..."
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew
                  fi
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL renewal completed successfully"
                  if [ "$DRY_RUN" != "true" ]; then
                    # Reload nginx to use renewed certificates
                    echo "üîÑ Reloading nginx with renewed certificates..."
                    cd docker-compose && docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload && cd ..
                  fi
                else
                  echo "‚ùå SSL renewal failed"
                  exit 1
                fi
                ;;
                
              "force-renew")
                echo "‚ö° Force renewing SSL certificates..."
                
                if [ -n "$DOMAIN" ]; then
                  echo "üéØ Force renewing certificate for domain: $DOMAIN"
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --force-renewal --cert-name "$DOMAIN"
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --force-renewal --cert-name "$DOMAIN"
                  fi
                else
                  echo "‚ö° Force renewing all certificates..."
                  if [ "$DRY_RUN" = "true" ]; then
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --dry-run --force-renewal
                  else
                    docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt -v /opt/cach/shared/ssl/www:/var/www/certbot certbot/certbot renew --force-renewal
                  fi
                fi
                
                if [ $? -eq 0 ]; then
                  echo "‚úÖ SSL force renewal completed successfully"
                  if [ "$DRY_RUN" != "true" ]; then
                    # Reload nginx to use renewed certificates
                    echo "üîÑ Reloading nginx with renewed certificates..."
                    cd docker-compose && docker-compose -f docker-compose.shared.yml exec -T nginx nginx -s reload && cd ..
                  fi
                else
                  echo "‚ùå SSL force renewal failed"
                  exit 1
                fi
                ;;
                
              "check-status")
                echo "üîç Checking SSL certificate status..."
                
                # List all certificates
                echo "üìã Current certificates:"
                docker run --rm -v /opt/cach/shared/ssl/letsencrypt:/etc/letsencrypt certbot/certbot certificates
                
                # Check expiration dates
                echo "üìÖ Certificate expiration check:"
                cert_dirs="/opt/cach/shared/ssl/letsencrypt/live/*"
                for cert_dir in $cert_dirs; do
                  if [ -d "$cert_dir" ]; then
                    domain=$(basename "$cert_dir")
                    cert_file="$cert_dir/fullchain.pem"
                    if [ -f "$cert_file" ]; then
                      echo "üîç Checking $domain..."
                      expiry=$(openssl x509 -enddate -noout -in "$cert_file" 2>/dev/null | cut -d= -f2)
                      if [ $? -eq 0 ]; then
                        echo "   üìÖ Expires: $expiry"
                        # Check if expires in next 30 days
                        expiry_epoch=$(date -d "$expiry" +%s 2>/dev/null)
                        current_epoch=$(date +%s)
                        days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))
                        if [ $days_until_expiry -lt 30 ]; then
                          echo "   ‚ö†Ô∏è  Certificate expires in $days_until_expiry days!"
                        else
                          echo "   ‚úÖ Certificate is valid for $days_until_expiry days"
                        fi
                      else
                        echo "   ‚ùå Invalid certificate file"
                      fi
                    else
                      echo "   ‚ùå Certificate file not found"
                    fi
                  fi
                done
                ;;
                
              "disable-https")
                echo "üîÑ Disabling HTTPS and switching back to HTTP-only configuration..."
                
                # Check if we have a backup of HTTP configs
                if [ -d "./nginx/conf.d-http-backup" ]; then
                  echo "üìã Restoring HTTP configuration from backup..."
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-http-backup ./nginx/conf.d
                else
                  echo "üìã No backup found, recreating HTTP configuration from source..."
                  
                  # Check which environment is currently deployed
                  if docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "production"; then
                    ENV_TYPE="production"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "staging"; then
                    ENV_TYPE="staging"
                  elif docker ps --format "table {{.Names}}\t{{.Status}}" | grep -q "sandbox"; then
                    ENV_TYPE="sandbox"
                  else
                    ENV_TYPE="shared"
                  fi
                  
                  # Create HTTP-only config directory
                  mkdir -p ./nginx/conf.d-http
                  
                  # Copy HTTP configurations based on environment
                  cp ./nginx/conf.d/shared-http.conf ./nginx/conf.d-http/
                  case "$ENV_TYPE" in
                    "production")
                      cp ./nginx/conf.d/production-http.conf ./nginx/conf.d-http/
                      ;;
                    "staging")
                      cp ./nginx/conf.d/staging-http.conf ./nginx/conf.d-http/
                      ;;
                    "sandbox")
                      cp ./nginx/conf.d/sandbox-http.conf ./nginx/conf.d-http/
                      ;;
                  esac
                  
                  # Replace with HTTP configurations
                  rm -rf ./nginx/conf.d
                  mv ./nginx/conf.d-http ./nginx/conf.d
                fi
                
                # Restart nginx with HTTP-only configuration
                echo "üîÑ Restarting nginx with HTTP-only configuration..."
                cd docker-compose
                docker-compose -f docker-compose.shared.yml stop nginx
                sleep 5
                docker-compose -f docker-compose.shared.yml up -d nginx
                cd ..
                
                echo "‚úÖ HTTPS disabled - services now running on HTTP only"
                echo "üìä HTTP Access points (environment-specific):"
                echo "   - Monitoring: http://monitoring.cachconnect.co.ke"
                echo "   - Other services depend on deployed environment (production/staging/sandbox)"
                ;;
                
              *)
                echo "‚ùå Unknown SSL action: $ACTION"
                exit 1
                ;;
            esac
            
            echo "üéâ SSL management operation completed successfully!"

  notification:
    runs-on: ubuntu-latest
    needs: [validate-ssl-request, ssl-management]
    if: failure() || (github.event_name == 'schedule' && needs.validate-ssl-request.outputs.action == 'renew')
    
    steps:
      - name: Notify SSL Status
        run: |
          ACTION="${{ needs.validate-ssl-request.outputs.action }}"
          STATUS="${{ job.status }}"
          
          echo "üìß SSL Management Notification"
          echo "Action: $ACTION"
          echo "Status: $STATUS"
          echo "Timestamp: $(date)"
          
          # Here you could add email notification, Slack webhook, etc.
          # For now, just log the result
          if [ "$STATUS" = "failure" ]; then
            echo "‚ùå SSL management failed - manual intervention may be required"
          else
            echo "‚úÖ SSL management completed successfully"
          fi
