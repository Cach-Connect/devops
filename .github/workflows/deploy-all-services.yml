name: Deploy All Services

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - sandbox
      services:
        description: 'Services to deploy (comma-separated or "all")'
        required: true
        default: 'all'
        type: string
      skip_build:
        description: 'Skip building images (use existing tags)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: docker.io

jobs:
  validate-deployment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      services: ${{ steps.set-env.outputs.services }}
      tag: ${{ steps.set-env.outputs.tag }}
      api_url: ${{ steps.set-env.outputs.api_url }}
    steps:
      - name: Determine environment and validate parameters
        id: set-env
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          SERVICES="${{ github.event.inputs.services }}"
          
          # Validate branch permissions
          if [[ "$ENVIRONMENT" == "production" && "${{ github.ref_name }}" != "main" ]]; then
            echo "‚ùå Cannot deploy to production from branch '${{ github.ref_name }}'. Only 'main' branch is allowed."
            exit 1
          elif [[ "$ENVIRONMENT" == "staging" && "${{ github.ref_name }}" != "staging" ]]; then
            echo "‚ùå Cannot deploy to staging from branch '${{ github.ref_name }}'. Only 'staging' branch is allowed."
            exit 1
          elif [[ "$ENVIRONMENT" == "sandbox" && "${{ github.ref_name }}" != "sandbox" ]]; then
            echo "‚ùå Cannot deploy to sandbox from branch '${{ github.ref_name }}'. Only 'sandbox' branch is allowed."
            exit 1
          fi
          
          TAG="${{ github.ref_name }}"
          
          # Set API URL based on environment
          case "$ENVIRONMENT" in
            "production")
              API_URL="https://api.cachconnect.co.ke"
              ;;
            "staging")
              API_URL="https://api.staging.cachconnect.co.ke"
              ;;
            "sandbox")
              API_URL="https://api.sandbox.cachconnect.co.ke"
              ;;
          esac
          
          # Process services list
          if [[ "$SERVICES" == "all" ]]; then
            SERVICES="api,admin,agents,distributors,business,lenders"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "services=$SERVICES" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Deploying services [$SERVICES] to $ENVIRONMENT environment using tag $TAG"

  build-images:
    runs-on: ubuntu-latest
    needs: validate-deployment
    if: ${{ github.event.inputs.skip_build != 'true' }}
    environment: ${{ needs.validate-deployment.outputs.environment }}
    strategy:
      matrix:
        service: [api, admin, agents, distributors, business, lenders]
    steps:
      - name: Check if service should be built
        id: check-service
        run: |
          SERVICES="${{ needs.validate-deployment.outputs.services }}"
          SERVICE="${{ matrix.service }}"
          
          if [[ ",$SERVICES," == *",$SERVICE,"* ]]; then
            echo "build=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Building $SERVICE"
          else
            echo "build=false" >> $GITHUB_OUTPUT
            echo "‚è≠Ô∏è Skipping $SERVICE"
          fi

      - name: Checkout code
        if: steps.check-service.outputs.build == 'true'
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: steps.check-service.outputs.build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        if: steps.check-service.outputs.build == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set image name
        if: steps.check-service.outputs.build == 'true'
        id: image-name
        run: |
          case "${{ matrix.service }}" in
            "api")
              IMAGE_NAME="abc254/cach-api"
              ;;
            "admin")
              IMAGE_NAME="abc254/cach-admin"
              ;;
            "agents")
              IMAGE_NAME="abc254/cach-agents"
              ;;
            "distributors")
              IMAGE_NAME="abc254/cach-distributors"
              ;;
            "business")
              IMAGE_NAME="abc254/cach-business"
              ;;
            "lenders")
              IMAGE_NAME="abc254/cach-lenders"
              ;;
          esac
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Extract metadata
        if: steps.check-service.outputs.build == 'true'
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.image-name.outputs.image_name }}
          tags: |
            type=raw,value=${{ needs.validate-deployment.outputs.tag }}
            type=sha,prefix=${{ needs.validate-deployment.outputs.tag }}-
            type=raw,value=latest,enable=${{ needs.validate-deployment.outputs.environment == 'production' }}

      - name: Build and push Docker image
        if: steps.check-service.outputs.build == 'true'
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            NEXT_PUBLIC_API_URL=${{ needs.validate-deployment.outputs.api_url }}
            NODE_ENV=${{ needs.validate-deployment.outputs.environment }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  deploy-services:
    runs-on: ubuntu-latest
    needs: [validate-deployment, build-images]
    if: always() && (needs.build-images.result == 'success' || needs.build-images.result == 'skipped')
    environment: ${{ needs.validate-deployment.outputs.environment }}
    
    steps:
      - name: Deploy to server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_SSH_PASSWORD }}
          envs: DATABASE_PASSWORD,MINIO_ROOT_USER,MINIO_ROOT_PASSWORD,API_IMAGE_NAME,DATABASE_URL,JWT_SECRET,JWT_EXPIRES_IN,MINIO_SECRET_KEY,MINIO_ACCESS_KEY,MINIO_BUCKET_NAME,MINIO_USE_SSL,MINIO_PORT,SMTP_HOST,SMTP_PORT,SMTP_SECURE,SMTP_USER,SMTP_PASS,SMTP_FROM_NAME,SMTP_FROM_EMAIL,SUPPORT_EMAIL,CORS_ORIGINS,ALLOWED_FILE_TYPES,MAX_FILE_SIZE,LOG_LEVEL,AGENT_IMAGE_NAME,DISTRIBUTOR_IMAGE_NAME,BUSINESS_IMAGE_NAME,ADMIN_IMAGE_NAME,LENDER_IMAGE_NAME,API_PRODUCTION_TAG,AGENT_PRODUCTION_TAG,DISTRIBUTOR_PRODUCTION_TAG,BUSINESS_PRODUCTION_TAG,ADMIN_PRODUCTION_TAG,LENDER_PRODUCTION_TAG,API_STAGING_TAG,AGENT_STAGING_TAG,DISTRIBUTOR_STAGING_TAG,BUSINESS_STAGING_TAG,ADMIN_STAGING_TAG,LENDER_STAGING_TAG,API_SANDBOX_TAG,AGENT_SANDBOX_TAG,DISTRIBUTOR_SANDBOX_TAG,BUSINESS_SANDBOX_TAG,ADMIN_SANDBOX_TAG,LENDER_SANDBOX_TAG
        env:
          # Database
          DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          
          # MinIO
          MINIO_ROOT_USER: ${{ secrets.MINIO_ROOT_USER }}
          MINIO_ROOT_PASSWORD: ${{ secrets.MINIO_ROOT_PASSWORD }}
          MINIO_SECRET_KEY: ${{ secrets.MINIO_SECRET_KEY }}
          MINIO_ACCESS_KEY: ${{ secrets.MINIO_ACCESS_KEY }}
          MINIO_BUCKET_NAME: ${{ vars.MINIO_BUCKET_NAME }}
          MINIO_USE_SSL: ${{ vars.MINIO_USE_SSL }}
          MINIO_PORT: ${{ vars.MINIO_PORT }}
          
          # JWT
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN: ${{ vars.JWT_EXPIRES_IN }}
          
          # SMTP
          SMTP_HOST: ${{ vars.SMTP_HOST }}
          SMTP_PORT: ${{ vars.SMTP_PORT }}
          SMTP_SECURE: ${{ vars.SMTP_SECURE }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
          SMTP_FROM_NAME: ${{ vars.SMTP_FROM_NAME }}
          SMTP_FROM_EMAIL: ${{ vars.SMTP_FROM_EMAIL }}
          SUPPORT_EMAIL: ${{ vars.SUPPORT_EMAIL }}
          
          # CORS and Security
          CORS_ORIGINS: ${{ vars.CORS_ORIGINS }}
          ALLOWED_FILE_TYPES: ${{ vars.ALLOWED_FILE_TYPES }}
          MAX_FILE_SIZE: ${{ vars.MAX_FILE_SIZE }}
          LOG_LEVEL: ${{ vars.LOG_LEVEL }}
          
          # Docker Images
          API_IMAGE_NAME: ${{ vars.API_IMAGE_NAME }}
          AGENT_IMAGE_NAME: ${{ vars.AGENT_IMAGE_NAME }}
          DISTRIBUTOR_IMAGE_NAME: ${{ vars.DISTRIBUTOR_IMAGE_NAME }}
          BUSINESS_IMAGE_NAME: ${{ vars.BUSINESS_IMAGE_NAME }}
          ADMIN_IMAGE_NAME: ${{ vars.ADMIN_IMAGE_NAME }}
          LENDER_IMAGE_NAME: ${{ vars.LENDER_IMAGE_NAME }}
          
          # Production Tags
          API_PRODUCTION_TAG: ${{ vars.API_PRODUCTION_TAG }}
          AGENT_PRODUCTION_TAG: ${{ vars.AGENT_PRODUCTION_TAG }}
          DISTRIBUTOR_PRODUCTION_TAG: ${{ vars.DISTRIBUTOR_PRODUCTION_TAG }}
          BUSINESS_PRODUCTION_TAG: ${{ vars.BUSINESS_PRODUCTION_TAG }}
          ADMIN_PRODUCTION_TAG: ${{ vars.ADMIN_PRODUCTION_TAG }}
          LENDER_PRODUCTION_TAG: ${{ vars.LENDER_PRODUCTION_TAG }}
          
          # Staging Tags
          API_STAGING_TAG: ${{ vars.API_STAGING_TAG }}
          AGENT_STAGING_TAG: ${{ vars.AGENT_STAGING_TAG }}
          DISTRIBUTOR_STAGING_TAG: ${{ vars.DISTRIBUTOR_STAGING_TAG }}
          BUSINESS_STAGING_TAG: ${{ vars.BUSINESS_STAGING_TAG }}
          ADMIN_STAGING_TAG: ${{ vars.ADMIN_STAGING_TAG }}
          LENDER_STAGING_TAG: ${{ vars.LENDER_STAGING_TAG }}
          
          # Sandbox Tags
          API_SANDBOX_TAG: ${{ vars.API_SANDBOX_TAG }}
          AGENT_SANDBOX_TAG: ${{ vars.AGENT_SANDBOX_TAG }}
          DISTRIBUTOR_SANDBOX_TAG: ${{ vars.DISTRIBUTOR_SANDBOX_TAG }}
          BUSINESS_SANDBOX_TAG: ${{ vars.BUSINESS_SANDBOX_TAG }}
          ADMIN_SANDBOX_TAG: ${{ vars.ADMIN_SANDBOX_TAG }}
          LENDER_SANDBOX_TAG: ${{ vars.LENDER_SANDBOX_TAG }}
          
          script: |
            set -e
            
            ENVIRONMENT="${{ needs.validate-deployment.outputs.environment }}"
            SERVICES="${{ needs.validate-deployment.outputs.services }}"
            TAG="${{ needs.validate-deployment.outputs.tag }}"
            SKIP_BUILD="${{ github.event.inputs.skip_build }}"
            
            echo "üöÄ Starting deployment to $ENVIRONMENT environment..."
            echo "üì¶ Services to deploy: $SERVICES"
            echo "üè∑Ô∏è  Using tag: $TAG"
            
            cd /opt/cach/$ENVIRONMENT
              
            # Set deployment-specific variables
            export ENVIRONMENT=$ENVIRONMENT
            export API_TAG=$TAG
            export ADMIN_TAG=$TAG
            export AGENT_TAG=$TAG
            export DISTRIBUTOR_TAG=$TAG
            export BUSINESS_TAG=$TAG
            export LENDER_TAG=$TAG
            
            # Function to pull image if not skipping build
            pull_image() {
              local service=$1
              local image_name=$2
              
              if [[ "$SKIP_BUILD" != "true" ]]; then
                echo "üì• Pulling $service image..."
                docker pull $image_name:$TAG
              else
                echo "‚è≠Ô∏è Skipping pull for $service (using existing image)"
              fi
            }
            
            # Function to deploy a service
            deploy_service() {
              local service=$1
              local image_name=$2
              local port=$3
              
              echo "üîÑ Deploying $service..."
              
              pull_image $service $image_name
              
              # Update the service
              docker-compose -f docker-compose.$ENVIRONMENT.yml up -d $service
              
              # Wait for service to be healthy
              echo "‚è≥ Waiting for $service to be healthy..."
              timeout=60
              while [ $timeout -gt 0 ]; do
                if curl -f http://127.0.0.1:$port > /dev/null 2>&1; then
                  echo "‚úÖ $service is healthy"
                  return 0
                fi
                echo "‚è≥ Waiting for $service... ($timeout seconds remaining)"
                sleep 5
                timeout=$((timeout-5))
              done
              
              echo "‚ùå $service failed to become healthy within 60 seconds"
              docker-compose -f docker-compose.$ENVIRONMENT.yml logs $service
              return 1
            }
            
            # Deploy each service
            IFS=',' read -ra SERVICE_ARRAY <<< "$SERVICES"
            FAILED_SERVICES=()
            
            for service in "${SERVICE_ARRAY[@]}"; do
              service=$(echo $service | xargs)  # Trim whitespace
              
              case "$service" in
                "api")
                  if [[ "$ENVIRONMENT" == "production" ]]; then PORT=3000; fi
                  if [[ "$ENVIRONMENT" == "staging" ]]; then PORT=3100; fi
                  if [[ "$ENVIRONMENT" == "sandbox" ]]; then PORT=3200; fi
                  deploy_service "api" "abc254/cach-api" $PORT || FAILED_SERVICES+=("api")
                  ;;
                "admin")
                  if [[ "$ENVIRONMENT" == "production" ]]; then PORT=3001; fi
                  if [[ "$ENVIRONMENT" == "staging" ]]; then PORT=3101; fi
                  if [[ "$ENVIRONMENT" == "sandbox" ]]; then PORT=3201; fi
                  deploy_service "admin" "abc254/cach-admin" $PORT || FAILED_SERVICES+=("admin")
                  ;;
                "agents")
                  if [[ "$ENVIRONMENT" == "production" ]]; then PORT=3002; fi
                  if [[ "$ENVIRONMENT" == "staging" ]]; then PORT=3102; fi
                  if [[ "$ENVIRONMENT" == "sandbox" ]]; then PORT=3202; fi
                  deploy_service "agents" "abc254/cach-agents" $PORT || FAILED_SERVICES+=("agents")
                  ;;
                "distributors")
                  if [[ "$ENVIRONMENT" == "production" ]]; then PORT=3003; fi
                  if [[ "$ENVIRONMENT" == "staging" ]]; then PORT=3103; fi
                  if [[ "$ENVIRONMENT" == "sandbox" ]]; then PORT=3203; fi
                  deploy_service "distributors" "abc254/cach-distributors" $PORT || FAILED_SERVICES+=("distributors")
                  ;;
                "business")
                  if [[ "$ENVIRONMENT" == "production" ]]; then PORT=3004; fi
                  if [[ "$ENVIRONMENT" == "staging" ]]; then PORT=3104; fi
                  if [[ "$ENVIRONMENT" == "sandbox" ]]; then PORT=3204; fi
                  deploy_service "business" "abc254/cach-business" $PORT || FAILED_SERVICES+=("business")
                  ;;
                "lenders")
                  if [[ "$ENVIRONMENT" == "production" ]]; then PORT=3005; fi
                  if [[ "$ENVIRONMENT" == "staging" ]]; then PORT=3105; fi
                  if [[ "$ENVIRONMENT" == "sandbox" ]]; then PORT=3205; fi
                  deploy_service "lenders" "abc254/cach-lenders" $PORT || FAILED_SERVICES+=("lenders")
                  ;;
                *)
                  echo "‚ö†Ô∏è Unknown service: $service"
                  ;;
              esac
            done
            
            # Clean up unused images
            echo "üßπ Cleaning up unused Docker images..."
            docker image prune -f
            
            # Report results
            if [ ${#FAILED_SERVICES[@]} -eq 0 ]; then
              echo "üéâ All services deployed successfully to $ENVIRONMENT environment!"
            else
              echo "‚ö†Ô∏è Some services failed to deploy:"
              printf '%s\n' "${FAILED_SERVICES[@]}"
              exit 1
            fi