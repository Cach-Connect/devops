name: Deploy Shared Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'shared'
        type: choice
        options:
          - shared
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - restart
          - stop

env:
  REGISTRY: docker.io

jobs:
  validate-deployment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      action: ${{ steps.set-env.outputs.action }}
    steps:
      - name: Determine environment and validate branch
        id: set-env
        run: |
          ENVIRONMENT="${{ github.event.inputs.environment }}"
          ACTION="${{ github.event.inputs.action }}"
          
          # Validate branch permissions for manual dispatch
          if [[ "$ENVIRONMENT" == "production" && "${{ github.ref_name }}" != "main" ]]; then
            echo "âŒ Cannot deploy to production from branch '${{ github.ref_name }}'. Only 'main' branch is allowed."
            exit 1
          elif [[ "$ENVIRONMENT" == "staging" && "${{ github.ref_name }}" != "staging" ]]; then
            echo "âŒ Cannot deploy to staging from branch '${{ github.ref_name }}'. Only 'staging' branch is allowed."
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "action=$ACTION" >> $GITHUB_OUTPUT
          echo "âœ… Deploying shared infrastructure to $ENVIRONMENT environment with action: $ACTION"

  deploy-shared-infrastructure:
    runs-on: ubuntu-latest
    needs: validate-deployment
    environment: ${{ needs.validate-deployment.outputs.environment }}
    
    steps:
      - name: SSH into server and deploy shared infrastructure
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_SSH_PASSWORD }}
          script: |
            cd ~

            # Get latest devops configuration
            echo "ğŸ“¥ Downloading latest devops configuration..."
            if [ -d "devops" ]; then
              echo "Devops directory exists, updating..."
              cd devops
              git pull origin main
            else
              echo "Devops directory doesn't exist, cloning..."
              git clone https://github.com/Cach-Connect/devops.git devops
              cd devops
            fi

            # Set environment variables
            ENVIRONMENT="${{ needs.validate-deployment.outputs.environment }}"
            ACTION="${{ needs.validate-deployment.outputs.action }}"
            
            echo "ğŸ”§ Environment: $ENVIRONMENT"
            echo "âš¡ Action: $ACTION"
            
            # Create shared deployment directory
            cd /opt/cach || (mkdir -p /opt/cach && cd /opt/cach)
            
            if [ ! -d "shared" ]; then
              mkdir -p shared
            fi
            cd shared
            
            # Copy all shared infrastructure files
            echo "ğŸ“‹ Copying shared infrastructure configuration..."
            cp ~/devops/docker-compose/docker-compose.shared.yml .
            
            # Copy monitoring configuration with proper structure
            echo "ğŸ“‹ Setting up monitoring configuration..."
            rm -rf monitoring && mkdir -p monitoring
            cp -r ~/devops/monitoring/* ./monitoring/
            
            # Ensure Grafana dashboards directory exists and has proper permissions
            echo "ğŸ“Š Setting up Grafana dashboards..."
            mkdir -p monitoring/grafana/dashboards
            if [ -f "~/devops/monitoring/grafana/dashboards/cach-overview.json" ]; then
              cp ~/devops/monitoring/grafana/dashboards/* ./monitoring/grafana/dashboards/ 2>/dev/null || true
            fi
            chmod -R 755 monitoring/grafana/dashboards
            
            # Copy nginx configuration (shared infrastructure only)
            echo "ğŸ“‹ Setting up nginx configuration (all environments)..."
            rm -rf nginx && mkdir -p nginx/conf.d
            cp ~/devops/nginx/nginx-http.conf ./nginx/nginx.conf

            # Copy all environment configurations to proper conf.d directory
            echo "ğŸ“‹ Loading production configurations..."
            cp ~/devops/nginx/conf.d/production-http.conf ./nginx/conf.d/

            echo "ğŸ“‹ Loading staging configurations..."
            cp ~/devops/nginx/conf.d/staging-http.conf ./nginx/conf.d/

            echo "ğŸ“‹ Loading sandbox configurations..."
            cp ~/devops/nginx/conf.d/sandbox-http.conf ./nginx/conf.d/

            echo "ğŸ“‹ Loading monitoring configurations..."
            cp ~/devops/nginx/conf.d/shared-http.conf ./nginx/conf.d/
            
            # Create SSL directories (certificates managed separately via SSL workflow)
            echo "ğŸ”’ Setting up SSL directories..."
            mkdir -p ssl/letsencrypt/live ssl/letsencrypt/archive ssl/www
            
            # Copy scripts
            echo "ğŸ“‹ Setting up scripts..."
            rm -rf scripts && mkdir -p scripts
            cp -r ~/devops/scripts/* ./scripts/
            
            # Create required directories
            mkdir -p logs
            
            # Set permissions for scripts
            chmod +x scripts/*.sh scripts/certbot/*.sh
            
            # Verify critical files exist
            echo "ğŸ” Verifying configuration files..."
            required_files=(
              "monitoring/prometheus/prometheus.yml"
              "monitoring/loki/loki.yml"
              "monitoring/promtail/promtail.yml"
              "monitoring/alertmanager/alertmanager.yml"
              "monitoring/grafana/provisioning/datasources/datasources.yml"
              "monitoring/grafana/dashboards/cach-overview.json"
              "nginx/nginx.conf"
              "nginx/conf.d/production-http.conf"
              "nginx/conf.d/staging-http.conf"
              "nginx/conf.d/sandbox-http.conf"
              "nginx/conf.d/shared-http.conf"
              "docker-compose.shared.yml"
            )
            
            for file in "${required_files[@]}"; do
              if [ -f "$file" ]; then
                echo "âœ… $file exists"
              else
                echo "âŒ $file is missing"
                echo "ğŸ“ Contents of $(dirname $file):"
                ls -la "$(dirname $file)" || echo "Directory doesn't exist"
                
                # Debug: show what was actually copied
                echo "ğŸ” Debug - showing actual file structure:"
                echo "Current directory: $(pwd)"
                echo "Top level files:"
                ls -la
                echo "Monitoring structure:"
                find . -name "*.yml" -o -name "*.yaml" | grep monitoring || echo "No monitoring yaml files found"
                
                exit 1
              fi
            done
            
            # Load environment variables from .env file
            echo "ğŸ“‹ Setting up environment configuration..."
            if [ -f ".env.monitoring" ]; then
              rm -f .env.monitoring
            fi
            cp ~/devops/env.monitoring.example .env.monitoring 2>/dev/null || echo "âš ï¸  No monitoring env file found, using defaults"
            
            # Perform the requested action
            case "$ACTION" in
              "deploy")
                echo "ğŸš€ Deploying shared infrastructure..."
                
                # Clean up any existing containers to avoid conflicts
                echo "ğŸ§¹ Cleaning up existing shared infrastructure..."
                docker-compose -f docker-compose.shared.yml down --remove-orphans 2>/dev/null || true
                
                # Start nginx first to ensure it's ready for service connections
                echo "ğŸš€ Starting nginx..."
                docker-compose -f docker-compose.shared.yml up -d nginx
                sleep 10
                
                # Verify nginx started successfully with retry
                echo "ğŸ” Checking nginx container status..."
                sleep 5  # Give nginx a moment to fully start
                
                if docker ps --filter "name=cach_nginx" --filter "status=running" | grep -q cach_nginx; then
                  echo "âœ… nginx container is running"
                  # Test if nginx is responding
                  if docker exec cach_nginx nginx -t >/dev/null 2>&1; then
                    echo "âœ… nginx configuration is valid and service is healthy"
                  else
                    echo "âš ï¸  nginx is running but configuration test failed (may be normal during startup)"
                  fi
                else
                  echo "âŒ nginx container is not running"
                  echo "ğŸ“‹ nginx container logs:"
                  docker logs cach_nginx --tail=20 2>/dev/null || echo "Could not get nginx logs"
                  echo "ğŸ“‹ All containers status:"
                  docker ps -a | grep nginx
                  exit 1
                fi
                
                # Pull latest images
                echo "ğŸ³ Pulling latest Docker images..."
                docker-compose -f docker-compose.shared.yml pull
                
                # Start all shared services
                echo "ğŸ”„ Starting shared services..."
                docker-compose -f docker-compose.shared.yml up -d
                
                # Wait for services to be ready
                echo "â³ Waiting for services to be ready..."
                sleep 30
                
                # Check service health with retries
                echo "ğŸ” Checking service health..."
                services=("prometheus" "grafana" "loki" "alertmanager" "nginx")
                max_retries=6
                retry_delay=10
                
                for service in "${services[@]}"; do
                  echo "ğŸ” Checking $service..."
                  retry_count=0
                  service_healthy=false
                  
                  while [ $retry_count -lt $max_retries ]; do
                    if docker ps --filter "name=cach_$service" --filter "status=running" | grep -q "cach_$service"; then
                      echo "âœ… $service is running"
                      service_healthy=true
                      break
                    else
                      retry_count=$((retry_count + 1))
                      if [ $retry_count -lt $max_retries ]; then
                        echo "â³ $service not ready, retrying in ${retry_delay}s... (attempt $retry_count/$max_retries)"
                        sleep $retry_delay
                      fi
                    fi
                  done
                  
                  if [ "$service_healthy" = false ]; then
                    echo "âŒ $service failed to start after $max_retries attempts"
                    echo "ğŸ” Debugging $service:"
                    echo "Container status:"
                    docker ps -a | grep "cach_$service" || echo "No $service container found"
                    echo "Container logs:"
                    docker logs "cach_$service" --tail=20 2>/dev/null || echo "Could not get $service logs"
                    
                    if [ "$service" = "nginx" ]; then
                      echo "ğŸ” Testing nginx config:"
                      docker exec cach_nginx nginx -t 2>/dev/null || echo "Could not test nginx config"
                    fi
                    
                    echo "âŒ Deployment failed due to $service not starting"
                    docker-compose -f docker-compose.shared.yml logs --tail=50
                    exit 1
                  fi
                done
                
                echo "âœ… All services are healthy and running"
                
                # Test HTTP endpoints to verify they're working
                echo "ğŸ” Testing HTTP endpoints..."
                
                # Test nginx health
                if curl -f -s http://localhost/ > /dev/null; then
                  echo "âœ… nginx responding to HTTP requests"
                else
                  echo "âš ï¸  nginx not responding to HTTP requests (may be normal if no default handler)"
                fi
                
                # Test Grafana (monitoring)
                if curl -f -s http://localhost:3000/api/health > /dev/null; then
                  echo "âœ… Grafana endpoint accessible"
                else
                  echo "âš ï¸  Grafana endpoint not accessible yet"
                fi
                
                # Test Prometheus
                if curl -f -s http://localhost:9090/-/healthy > /dev/null; then
                  echo "âœ… Prometheus endpoint accessible"
                else
                  echo "âš ï¸  Prometheus endpoint not accessible yet"
                fi
                
                echo "ğŸ‰ Shared infrastructure deployment completed successfully!"
                echo "ğŸ“Š Nginx is configured for all environments:"
                echo "   ğŸ­ Production: cachconnect.co.ke, api.cachconnect.co.ke, admin.cachconnect.co.ke, etc."
                echo "   ğŸ§ª Staging: staging.cachconnect.co.ke, api.staging.cachconnect.co.ke, etc."
                echo "   ğŸ”¬ Sandbox: sandbox.cachconnect.co.ke, api.sandbox.cachconnect.co.ke, etc."
                echo "   ğŸ“Š Monitoring: monitoring.cachconnect.co.ke"
                echo ""
                echo "ğŸ“Š Direct service access (development only):"
                echo "   - Prometheus: http://${{ secrets.VPS_HOST }}:9090"
                echo "   - Alertmanager: http://${{ secrets.VPS_HOST }}:9093"
                echo "   - Loki (Logs): http://${{ secrets.VPS_HOST }}:3100"
                echo ""
                echo "âš ï¸  Domains will show 'service starting up' until you deploy the respective environments"
                echo "ğŸ“‹ Next steps:"
                echo "   - Deploy production services to activate: cachconnect.co.ke, api.cachconnect.co.ke, etc."
                echo "   - Deploy staging services to activate: staging.cachconnect.co.ke, etc."
                echo "   - Deploy sandbox services to activate: sandbox.cachconnect.co.ke, etc."
                echo "   - Run 'SSL Certificate Management' to enable HTTPS"
                echo "   - All unknown domains and IP access are blocked (return 444)"
                ;;
                
              "restart")
                echo "ğŸ”„ Restarting shared services..."
                docker-compose -f docker-compose.shared.yml restart
                echo "âœ… Shared services restarted successfully"
                ;;
                
              "stop")
                echo "ğŸ›‘ Stopping shared services..."
                docker-compose -f docker-compose.shared.yml down
                echo "âœ… Shared services stopped successfully"
                ;;
                

              *)
                echo "âŒ Unknown action: $ACTION"
                exit 1
                ;;
            esac
            
            # Clean up unused images and containers
            echo "ğŸ§¹ Cleaning up unused Docker resources..."
            docker system prune -f
            
            # Show final status
            echo "ğŸ“‹ Final service status:"
            docker-compose -f docker-compose.shared.yml ps
            
            echo "ğŸ‰ Shared infrastructure operation completed successfully!"

  post-deployment-checks:
    runs-on: ubuntu-latest
    needs: [validate-deployment, deploy-shared-infrastructure]
    if: needs.validate-deployment.outputs.action == 'deploy'
    environment: ${{ needs.validate-deployment.outputs.environment }}
    
    steps:
      - name: Verify deployment health
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          password: ${{ secrets.VPS_SSH_PASSWORD }}
          script: |
            cd /opt/cach/shared
            
            echo "ğŸ” Running post-deployment health checks..."
            
            # Check if all containers are running
            if ! docker-compose -f docker-compose.shared.yml ps | grep -q "Up"; then
              echo "âŒ Some containers are not running"
              docker-compose -f docker-compose.shared.yml ps
              exit 1
            fi
            
            # Test Prometheus endpoint
            echo "ğŸ” Testing Prometheus..."
            timeout=30
            while [ $timeout -gt 0 ]; do
              if curl -s http://localhost:9090/-/healthy > /dev/null; then
                echo "âœ… Prometheus is healthy"
                break
              fi
              echo "â³ Waiting for Prometheus... ($timeout seconds remaining)"
              sleep 5
              timeout=$((timeout-5))
            done
            
            if [ $timeout -le 0 ]; then
              echo "âŒ Prometheus health check failed"
              exit 1
            fi
            
            # Test Grafana endpoint
            echo "ğŸ” Testing Grafana..."
            timeout=30
            while [ $timeout -gt 0 ]; do
              if curl -s http://localhost:3000/api/health > /dev/null; then
                echo "âœ… Grafana is healthy"
                break
              fi
              echo "â³ Waiting for Grafana... ($timeout seconds remaining)"
              sleep 5
              timeout=$((timeout-5))
            done
            
            if [ $timeout -le 0 ]; then
              echo "âŒ Grafana health check failed"
              exit 1
            fi
            
            # Test Loki endpoint
            echo "ğŸ” Testing Loki..."
            if curl -s http://localhost:3100/ready > /dev/null; then
              echo "âœ… Loki is healthy"
            else
              echo "âŒ Loki health check failed"
              exit 1
            fi
            
            # Test Alertmanager endpoint
            echo "ğŸ” Testing Alertmanager..."
            if curl -s http://localhost:9093/-/healthy > /dev/null; then
              echo "âœ… Alertmanager is healthy"
            else
              echo "âŒ Alertmanager health check failed"
              exit 1
            fi
            
            echo "ğŸ‰ All health checks passed successfully!"
            echo "ğŸ“Š Monitoring stack is fully operational"
